// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package queries

import (
	"context"
	"database/sql"
	"strings"
	"time"
)

const countUserActiveAPITokens = `-- name: CountUserActiveAPITokens :one
SELECT COUNT(*) as count
FROM api_tokens
WHERE user_id = ? AND revoked_at IS NULL
`

func (q *Queries) CountUserActiveAPITokens(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUserActiveAPITokens, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserArticleVectorsByThumbsDown = `-- name: CountUserArticleVectorsByThumbsDown :one
SELECT COUNT(*) as count
FROM user_article_interactions
WHERE user_id = ? AND thumbs_down = TRUE AND ` + "`" + `vector` + "`" + ` IS NOT NULL
`

func (q *Queries) CountUserArticleVectorsByThumbsDown(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUserArticleVectorsByThumbsDown, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserArticleVectorsByThumbsUp = `-- name: CountUserArticleVectorsByThumbsUp :one
SELECT COUNT(*) as count
FROM user_article_interactions
WHERE user_id = ? AND thumbs_up = TRUE AND ` + "`" + `vector` + "`" + ` IS NOT NULL
`

func (q *Queries) CountUserArticleVectorsByThumbsUp(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUserArticleVectorsByThumbsUp, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAPIToken = `-- name: CreateAPIToken :exec

INSERT INTO api_tokens (id, user_id, token_hash, token_prefix, name, created_at, expires_at)
VALUES (?, ?, ?, ?, ?, NOW(), ?)
`

type CreateAPITokenParams struct {
	ID          string
	UserID      string
	TokenHash   string
	TokenPrefix string
	Name        sql.NullString
	ExpiresAt   sql.NullTime
}

// ============================================
// API Tokens
// ============================================
func (q *Queries) CreateAPIToken(ctx context.Context, arg CreateAPITokenParams) error {
	_, err := q.db.ExecContext(ctx, createAPIToken,
		arg.ID,
		arg.UserID,
		arg.TokenHash,
		arg.TokenPrefix,
		arg.Name,
		arg.ExpiresAt,
	)
	return err
}

const deleteUserInterestClusters = `-- name: DeleteUserInterestClusters :exec
DELETE FROM user_interest_clusters
WHERE user_id = ?
`

func (q *Queries) DeleteUserInterestClusters(ctx context.Context, userID string) error {
	_, err := q.db.ExecContext(ctx, deleteUserInterestClusters, userID)
	return err
}

const deleteUserPrecomputedRecommendations = `-- name: DeleteUserPrecomputedRecommendations :exec
DELETE FROM user_precomputed_recommendations
WHERE user_id = ?
`

func (q *Queries) DeleteUserPrecomputedRecommendations(ctx context.Context, userID string) error {
	_, err := q.db.ExecContext(ctx, deleteUserPrecomputedRecommendations, userID)
	return err
}

const fetchArticlesByID = `-- name: FetchArticlesByID :many
SELECT
    hash_id,
    title,
    url,
    source,
    LEFT(COALESCE(text, ''), 500) as text_start,
    authors,
    date_published,
    summary,
    key_points,
    implication,
    category,
    have_read,
    thumbs_up,
    thumbs_down
FROM articles
LEFT JOIN user_article_interactions
    ON articles.hash_id = user_article_interactions.article_hash_id
        AND user_article_interactions.user_id = ?
WHERE hash_id IN (/*SLICE:hash_ids*/?)
`

type FetchArticlesByIDParams struct {
	UserID  string
	HashIds []string
}

type FetchArticlesByIDRow struct {
	HashID        string
	Title         sql.NullString
	Url           sql.NullString
	Source        sql.NullString
	TextStart     string
	Authors       string
	DatePublished sql.NullTime
	Summary       sql.NullString
	KeyPoints     sql.NullString
	Implication   sql.NullString
	Category      sql.NullString
	HaveRead      sql.NullBool
	ThumbsUp      sql.NullBool
	ThumbsDown    sql.NullBool
}

func (q *Queries) FetchArticlesByID(ctx context.Context, arg FetchArticlesByIDParams) ([]FetchArticlesByIDRow, error) {
	query := fetchArticlesByID
	var queryParams []interface{}
	queryParams = append(queryParams, arg.UserID)
	if len(arg.HashIds) > 0 {
		for _, v := range arg.HashIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:hash_ids*/?", strings.Repeat(",?", len(arg.HashIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:hash_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchArticlesByIDRow
	for rows.Next() {
		var i FetchArticlesByIDRow
		if err := rows.Scan(
			&i.HashID,
			&i.Title,
			&i.Url,
			&i.Source,
			&i.TextStart,
			&i.Authors,
			&i.DatePublished,
			&i.Summary,
			&i.KeyPoints,
			&i.Implication,
			&i.Category,
			&i.HaveRead,
			&i.ThumbsUp,
			&i.ThumbsDown,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAPITokenByHash = `-- name: GetAPITokenByHash :one
SELECT id, user_id, token_hash, token_prefix, name, created_at, last_used_at, expires_at, revoked_at
FROM api_tokens
WHERE token_hash = ?
`

func (q *Queries) GetAPITokenByHash(ctx context.Context, tokenHash string) (ApiToken, error) {
	row := q.db.QueryRowContext(ctx, getAPITokenByHash, tokenHash)
	var i ApiToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.TokenPrefix,
		&i.Name,
		&i.CreatedAt,
		&i.LastUsedAt,
		&i.ExpiresAt,
		&i.RevokedAt,
	)
	return i, err
}

const getPrecomputedRecommendationAge = `-- name: GetPrecomputedRecommendationAge :one
SELECT generated_at
FROM user_precomputed_recommendations
WHERE user_id = ?
ORDER BY generated_at DESC
LIMIT 1
`

func (q *Queries) GetPrecomputedRecommendationAge(ctx context.Context, userID string) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, getPrecomputedRecommendationAge, userID)
	var generated_at time.Time
	err := row.Scan(&generated_at)
	return generated_at, err
}

const getPrecomputedRecommendations = `-- name: GetPrecomputedRecommendations :many
SELECT article_hash_id, score, source, position, generated_at
FROM user_precomputed_recommendations
WHERE user_id = ?
ORDER BY position ASC
LIMIT ?
`

type GetPrecomputedRecommendationsParams struct {
	UserID string
	Limit  int32
}

type GetPrecomputedRecommendationsRow struct {
	ArticleHashID string
	Score         float64
	Source        string
	Position      int32
	GeneratedAt   time.Time
}

func (q *Queries) GetPrecomputedRecommendations(ctx context.Context, arg GetPrecomputedRecommendationsParams) ([]GetPrecomputedRecommendationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPrecomputedRecommendations, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPrecomputedRecommendationsRow
	for rows.Next() {
		var i GetPrecomputedRecommendationsRow
		if err := rows.Scan(
			&i.ArticleHashID,
			&i.Score,
			&i.Source,
			&i.Position,
			&i.GeneratedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserArticleInteraction = `-- name: GetUserArticleInteraction :one

SELECT user_id, article_hash_id, have_read, thumbs_up, thumbs_down,
       date_read, date_rated, ` + "`" + `vector` + "`" + `
FROM user_article_interactions
WHERE user_id = ? AND article_hash_id = ?
`

type GetUserArticleInteractionParams struct {
	UserID        string
	ArticleHashID string
}

// ============================================
// User Article Interactions (unified table)
// ============================================
func (q *Queries) GetUserArticleInteraction(ctx context.Context, arg GetUserArticleInteractionParams) (UserArticleInteraction, error) {
	row := q.db.QueryRowContext(ctx, getUserArticleInteraction, arg.UserID, arg.ArticleHashID)
	var i UserArticleInteraction
	err := row.Scan(
		&i.UserID,
		&i.ArticleHashID,
		&i.HaveRead,
		&i.ThumbsUp,
		&i.ThumbsDown,
		&i.DateRead,
		&i.DateRated,
		&i.Vector,
	)
	return i, err
}

const getUserArticleVectorsByThumbsDown = `-- name: GetUserArticleVectorsByThumbsDown :many
SELECT article_hash_id, ` + "`" + `vector` + "`" + `, date_rated
FROM user_article_interactions
WHERE user_id = ? AND thumbs_down = TRUE AND ` + "`" + `vector` + "`" + ` IS NOT NULL
ORDER BY date_rated DESC
`

type GetUserArticleVectorsByThumbsDownRow struct {
	ArticleHashID string
	Vector        sql.NullString
	DateRated     sql.NullTime
}

func (q *Queries) GetUserArticleVectorsByThumbsDown(ctx context.Context, userID string) ([]GetUserArticleVectorsByThumbsDownRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserArticleVectorsByThumbsDown, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserArticleVectorsByThumbsDownRow
	for rows.Next() {
		var i GetUserArticleVectorsByThumbsDownRow
		if err := rows.Scan(&i.ArticleHashID, &i.Vector, &i.DateRated); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserArticleVectorsByThumbsUp = `-- name: GetUserArticleVectorsByThumbsUp :many
SELECT article_hash_id, ` + "`" + `vector` + "`" + `, date_rated
FROM user_article_interactions
WHERE user_id = ? AND thumbs_up = TRUE AND ` + "`" + `vector` + "`" + ` IS NOT NULL
ORDER BY date_rated DESC
`

type GetUserArticleVectorsByThumbsUpRow struct {
	ArticleHashID string
	Vector        sql.NullString
	DateRated     sql.NullTime
}

func (q *Queries) GetUserArticleVectorsByThumbsUp(ctx context.Context, userID string) ([]GetUserArticleVectorsByThumbsUpRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserArticleVectorsByThumbsUp, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserArticleVectorsByThumbsUpRow
	for rows.Next() {
		var i GetUserArticleVectorsByThumbsUpRow
		if err := rows.Scan(&i.ArticleHashID, &i.Vector, &i.DateRated); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserInterestClusters = `-- name: GetUserInterestClusters :many
SELECT cluster_id, centroid_vector, article_count, updated_at
FROM user_interest_clusters
WHERE user_id = ?
ORDER BY cluster_id
`

type GetUserInterestClustersRow struct {
	ClusterID      int32
	CentroidVector []byte
	ArticleCount   int32
	UpdatedAt      time.Time
}

func (q *Queries) GetUserInterestClusters(ctx context.Context, userID string) ([]GetUserInterestClustersRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserInterestClusters, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserInterestClustersRow
	for rows.Next() {
		var i GetUserInterestClustersRow
		if err := rows.Scan(
			&i.ClusterID,
			&i.CentroidVector,
			&i.ArticleCount,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserRecommendationState = `-- name: GetUserRecommendationState :one

SELECT last_generated_at, last_rating_at, needs_regeneration
FROM user_recommendation_state
WHERE user_id = ?
`

type GetUserRecommendationStateRow struct {
	LastGeneratedAt   sql.NullTime
	LastRatingAt      sql.NullTime
	NeedsRegeneration bool
}

// ============================================
// User Recommendation State
// ============================================
func (q *Queries) GetUserRecommendationState(ctx context.Context, userID string) (GetUserRecommendationStateRow, error) {
	row := q.db.QueryRowContext(ctx, getUserRecommendationState, userID)
	var i GetUserRecommendationStateRow
	err := row.Scan(&i.LastGeneratedAt, &i.LastRatingAt, &i.NeedsRegeneration)
	return i, err
}

const insertArticle = `-- name: InsertArticle :exec
INSERT INTO articles (
                      hash_id,
                      title,
                      url,
                      source,
                      text,
                      authors,
                      date_published,
                      date_created,
                      pinecone_status,
                      date_checked) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertArticleParams struct {
	HashID         string
	Title          sql.NullString
	Url            sql.NullString
	Source         sql.NullString
	Text           sql.NullString
	Authors        string
	DatePublished  sql.NullTime
	DateCreated    time.Time
	PineconeStatus ArticlesPineconeStatus
	DateChecked    time.Time
}

func (q *Queries) InsertArticle(ctx context.Context, arg InsertArticleParams) error {
	_, err := q.db.ExecContext(ctx, insertArticle,
		arg.HashID,
		arg.Title,
		arg.Url,
		arg.Source,
		arg.Text,
		arg.Authors,
		arg.DatePublished,
		arg.DateCreated,
		arg.PineconeStatus,
		arg.DateChecked,
	)
	return err
}

const listDislikedArticleIDs = `-- name: ListDislikedArticleIDs :many
SELECT article_hash_id FROM user_article_interactions
WHERE user_id = ? AND thumbs_down = TRUE
ORDER BY date_rated DESC
LIMIT ? OFFSET ?
`

type ListDislikedArticleIDsParams struct {
	UserID string
	Limit  int32
	Offset int32
}

func (q *Queries) ListDislikedArticleIDs(ctx context.Context, arg ListDislikedArticleIDsParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listDislikedArticleIDs, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var article_hash_id string
		if err := rows.Scan(&article_hash_id); err != nil {
			return nil, err
		}
		items = append(items, article_hash_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLikedArticleIDs = `-- name: ListLikedArticleIDs :many
SELECT article_hash_id FROM user_article_interactions
WHERE user_id = ? AND thumbs_up = TRUE
ORDER BY date_rated DESC
LIMIT ? OFFSET ?
`

type ListLikedArticleIDsParams struct {
	UserID string
	Limit  int32
	Offset int32
}

func (q *Queries) ListLikedArticleIDs(ctx context.Context, arg ListLikedArticleIDsParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listLikedArticleIDs, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var article_hash_id string
		if err := rows.Scan(&article_hash_id); err != nil {
			return nil, err
		}
		items = append(items, article_hash_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReadArticleIDs = `-- name: ListReadArticleIDs :many
SELECT article_hash_id FROM user_article_interactions
WHERE user_id = ? AND have_read = TRUE
`

func (q *Queries) ListReadArticleIDs(ctx context.Context, userID string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listReadArticleIDs, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var article_hash_id string
		if err := rows.Scan(&article_hash_id); err != nil {
			return nil, err
		}
		items = append(items, article_hash_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listThumbsUpArticleIDs = `-- name: ListThumbsUpArticleIDs :many
SELECT article_hash_id FROM user_article_interactions
WHERE user_id = ? AND thumbs_up = TRUE
`

func (q *Queries) ListThumbsUpArticleIDs(ctx context.Context, userID string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listThumbsUpArticleIDs, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var article_hash_id string
		if err := rows.Scan(&article_hash_id); err != nil {
			return nil, err
		}
		items = append(items, article_hash_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnreviewedArticleIDs = `-- name: ListUnreviewedArticleIDs :many
SELECT article_hash_id FROM user_article_interactions
WHERE user_id = ?
    AND have_read = TRUE
    AND thumbs_up = FALSE
    AND thumbs_down = FALSE
ORDER BY date_read DESC
LIMIT ? OFFSET ?
`

type ListUnreviewedArticleIDsParams struct {
	UserID string
	Limit  int32
	Offset int32
}

func (q *Queries) ListUnreviewedArticleIDs(ctx context.Context, arg ListUnreviewedArticleIDsParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listUnreviewedArticleIDs, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var article_hash_id string
		if err := rows.Scan(&article_hash_id); err != nil {
			return nil, err
		}
		items = append(items, article_hash_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserAPITokens = `-- name: ListUserAPITokens :many
SELECT id, user_id, token_hash, token_prefix, name, created_at, last_used_at, expires_at, revoked_at
FROM api_tokens
WHERE user_id = ?
ORDER BY created_at DESC
`

func (q *Queries) ListUserAPITokens(ctx context.Context, userID string) ([]ApiToken, error) {
	rows, err := q.db.QueryContext(ctx, listUserAPITokens, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApiToken
	for rows.Next() {
		var i ApiToken
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TokenHash,
			&i.TokenPrefix,
			&i.Name,
			&i.CreatedAt,
			&i.LastUsedAt,
			&i.ExpiresAt,
			&i.RevokedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersNeedingRegeneration = `-- name: ListUsersNeedingRegeneration :many
SELECT user_id
FROM user_recommendation_state
WHERE needs_regeneration = TRUE
ORDER BY last_rating_at ASC
`

func (q *Queries) ListUsersNeedingRegeneration(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listUsersNeedingRegeneration)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var user_id string
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markUserNeedsRegeneration = `-- name: MarkUserNeedsRegeneration :exec
INSERT INTO user_recommendation_state (user_id, last_rating_at, needs_regeneration)
VALUES (?, NOW(), TRUE)
ON DUPLICATE KEY UPDATE
    last_rating_at = NOW(),
    needs_regeneration = TRUE
`

func (q *Queries) MarkUserNeedsRegeneration(ctx context.Context, userID string) error {
	_, err := q.db.ExecContext(ctx, markUserNeedsRegeneration, userID)
	return err
}

const markUserRegenerated = `-- name: MarkUserRegenerated :exec
UPDATE user_recommendation_state
SET last_generated_at = NOW(), needs_regeneration = FALSE
WHERE user_id = ?
`

func (q *Queries) MarkUserRegenerated(ctx context.Context, userID string) error {
	_, err := q.db.ExecContext(ctx, markUserRegenerated, userID)
	return err
}

const revokeAPIToken = `-- name: RevokeAPIToken :exec
UPDATE api_tokens
SET revoked_at = NOW()
WHERE id = ? AND user_id = ?
`

type RevokeAPITokenParams struct {
	ID     string
	UserID string
}

func (q *Queries) RevokeAPIToken(ctx context.Context, arg RevokeAPITokenParams) error {
	_, err := q.db.ExecContext(ctx, revokeAPIToken, arg.ID, arg.UserID)
	return err
}

const setArticleRead = `-- name: SetArticleRead :exec
INSERT INTO user_article_interactions (
        user_id,
        article_hash_id,
        have_read,
        thumbs_up,
        thumbs_down,
        date_read
    ) VALUES (?, ?, ?, FALSE, FALSE, ?)
ON DUPLICATE KEY UPDATE
    have_read = ?,
    date_read = COALESCE(date_read, ?)
`

type SetArticleReadParams struct {
	UserID        string
	ArticleHashID string
	HaveRead      bool
	DateRead      sql.NullTime
}

func (q *Queries) SetArticleRead(ctx context.Context, arg SetArticleReadParams) error {
	_, err := q.db.ExecContext(ctx, setArticleRead,
		arg.UserID,
		arg.ArticleHashID,
		arg.HaveRead,
		arg.DateRead,
		arg.HaveRead,
		arg.DateRead,
	)
	return err
}

const updateAPITokenLastUsed = `-- name: UpdateAPITokenLastUsed :exec
UPDATE api_tokens
SET last_used_at = NOW()
WHERE id = ?
`

func (q *Queries) UpdateAPITokenLastUsed(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, updateAPITokenLastUsed, id)
	return err
}

const upsertPrecomputedRecommendation = `-- name: UpsertPrecomputedRecommendation :exec

INSERT INTO user_precomputed_recommendations (user_id, article_hash_id, score, source, position, generated_at)
VALUES (?, ?, ?, ?, ?, ?)
ON DUPLICATE KEY UPDATE
    score = VALUES(score),
    source = VALUES(source),
    position = VALUES(position),
    generated_at = VALUES(generated_at)
`

type UpsertPrecomputedRecommendationParams struct {
	UserID        string
	ArticleHashID string
	Score         float64
	Source        string
	Position      int32
	GeneratedAt   time.Time
}

// ============================================
// Precomputed Recommendations
// ============================================
func (q *Queries) UpsertPrecomputedRecommendation(ctx context.Context, arg UpsertPrecomputedRecommendationParams) error {
	_, err := q.db.ExecContext(ctx, upsertPrecomputedRecommendation,
		arg.UserID,
		arg.ArticleHashID,
		arg.Score,
		arg.Source,
		arg.Position,
		arg.GeneratedAt,
	)
	return err
}

const upsertUserArticleInteraction = `-- name: UpsertUserArticleInteraction :exec
INSERT INTO user_article_interactions (
    user_id, article_hash_id, have_read, thumbs_up, thumbs_down,
    date_read, date_rated, ` + "`" + `vector` + "`" + `
) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
ON DUPLICATE KEY UPDATE
    have_read = VALUES(have_read),
    thumbs_up = VALUES(thumbs_up),
    thumbs_down = VALUES(thumbs_down),
    date_read = VALUES(date_read),
    date_rated = VALUES(date_rated),
    ` + "`" + `vector` + "`" + ` = VALUES(` + "`" + `vector` + "`" + `)
`

type UpsertUserArticleInteractionParams struct {
	UserID        string
	ArticleHashID string
	HaveRead      bool
	ThumbsUp      bool
	ThumbsDown    bool
	DateRead      sql.NullTime
	DateRated     sql.NullTime
	Vector        sql.NullString
}

func (q *Queries) UpsertUserArticleInteraction(ctx context.Context, arg UpsertUserArticleInteractionParams) error {
	_, err := q.db.ExecContext(ctx, upsertUserArticleInteraction,
		arg.UserID,
		arg.ArticleHashID,
		arg.HaveRead,
		arg.ThumbsUp,
		arg.ThumbsDown,
		arg.DateRead,
		arg.DateRated,
		arg.Vector,
	)
	return err
}

const upsertUserInterestCluster = `-- name: UpsertUserInterestCluster :exec

INSERT INTO user_interest_clusters (user_id, cluster_id, centroid_vector, article_count, updated_at)
VALUES (?, ?, ?, ?, NOW())
ON DUPLICATE KEY UPDATE
    centroid_vector = VALUES(centroid_vector),
    article_count = VALUES(article_count),
    updated_at = NOW()
`

type UpsertUserInterestClusterParams struct {
	UserID         string
	ClusterID      int32
	CentroidVector []byte
	ArticleCount   int32
}

// ============================================
// User Interest Clusters
// ============================================
func (q *Queries) UpsertUserInterestCluster(ctx context.Context, arg UpsertUserInterestClusterParams) error {
	_, err := q.db.ExecContext(ctx, upsertUserInterestCluster,
		arg.UserID,
		arg.ClusterID,
		arg.CentroidVector,
		arg.ArticleCount,
	)
	return err
}

const upsertUserRecommendationState = `-- name: UpsertUserRecommendationState :exec
INSERT INTO user_recommendation_state (user_id, last_generated_at, last_rating_at, needs_regeneration)
VALUES (?, ?, ?, ?)
ON DUPLICATE KEY UPDATE
    last_generated_at = COALESCE(VALUES(last_generated_at), last_generated_at),
    last_rating_at = COALESCE(VALUES(last_rating_at), last_rating_at),
    needs_regeneration = VALUES(needs_regeneration)
`

type UpsertUserRecommendationStateParams struct {
	UserID            string
	LastGeneratedAt   sql.NullTime
	LastRatingAt      sql.NullTime
	NeedsRegeneration bool
}

func (q *Queries) UpsertUserRecommendationState(ctx context.Context, arg UpsertUserRecommendationStateParams) error {
	_, err := q.db.ExecContext(ctx, upsertUserRecommendationState,
		arg.UserID,
		arg.LastGeneratedAt,
		arg.LastRatingAt,
		arg.NeedsRegeneration,
	)
	return err
}
